<?xml version="1.0" encoding="UTF-8"?>
<section id="actions-send">
    <title>Sending messages</title>

    <para>In a integration test scenario we want to trigger processes and call interface services on the system under test. In order to do this we need to be able to
    send messages to various message transports. Therefore the send message test action in Citrus is one of the most important test actions. First of all let us
    have a look at the Citrus message definition in Citrus:</para>

    <mediaobject>
        <imageobject role="fo">
            <imagedata align="center" width="200px" scale="100" fileref="figure_001.jpg" format="JPG" />
        </imageobject>

        <imageobject role="html">
            <imagedata align="center" display="block" fileref="figure_001.jpg" format="JPG" />
        </imageobject>
    </mediaobject>

    <para>A message consists of a message header (name-value pairs) and a message payload. Later in this section we will see different ways of constructing a message
    with payload and header values. But first of all let's concentrate on a simple sending message action inside a test case.</para>

    <para><emphasis>XML DSL</emphasis></para>
    <programlisting>&lt;testcase name=&quot;SendMessageTest&quot;&gt;
    &lt;description&gt;Basic send message example&lt;/description&gt;

    &lt;variables&gt;
        &lt;variable name=&quot;text&quot; value=&quot;Hello Citrus!&quot;/&gt;
        &lt;variable name=&quot;messageId&quot; value=&quot;Mx1x123456789&quot;/&gt;
    &lt;/variables&gt;

    &lt;actions&gt;
        &lt;send endpoint=&quot;helloServiceEndpoint&quot;&gt;
            &lt;message&gt;
                &lt;payload&gt;
                    &lt;TestMessage&gt;
                        &lt;Text&gt;${text}&lt;/Text&gt;
                    &lt;/TestMessage&gt;
                &lt;/payload&gt;
            &lt;/message&gt;
            &lt;header&gt;
                &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
                &lt;element name=&quot;MessageId&quot; value=&quot;${messageId}&quot;/&gt;
            &lt;/header&gt;
        &lt;/send&gt;
    &lt;/actions&gt;
&lt;/testcase&gt;</programlisting>

    <para>The sample uses both header and payload as message parts to send. In both parts you can use variable definitions
    (see <emphasis>${text}</emphasis> and <emphasis>${messageId}</emphasis>). So first of all let us recap what variables do.
    Test variables are defined at the very beginning of the test case and are valid throughout all actions that take place in
    the test. This means that actions can simply reference a variable by the expression <literal>${variable-name}</literal>.</para>

    <tip>
        <para>Use variables wherever you can! At least the important entities of a test should be defined as variables at the
        beginning. The test case improves maintainability and flexibility when using variables.</para>
    </tip>

    <para>Now lets have a closer look at the sending action. The <emphasis>'endpoint'</emphasis> attribute might catch your attention first.
    This attribute references a message endpoint in Citrus configuration by name. As previously mentioned the message endpoint
    definition lives in a separate configuration file and contains the actual message transport settings. In this example the
    <emphasis>&quot;helloServiceEndpoint&quot;</emphasis> is referenced which is a message endpoint for sending out messages via
    JMS or HTTP for instance.</para>

    <para>The test case is not aware of any transport details, because it does not have to. The advantages are obvious: On the one hand multiple test
    cases can reference the message endpoint definition for better reuse. Secondly test cases are independent of message transport details.
    So connection factories, user credentials, endpoint uri values and so on are not present in the test case.</para>

    <para>In other words the <emphasis>&quot;endpoint&quot;</emphasis> attribute of the <emphasis>&lt;send&gt;</emphasis> element specifies
    which message endpoint definition to use and therefore where the message should go to. Once again all available message endpoints are
    configured in a separate Citrus configuration file. We will come to this later on. Be sure to always pick the right message endpoint type
    in order to publish your message to the right destination.</para>

    <para>If you do not like the XML language you can also use pure Java code to define the same test. In Java you would also make use of the message endpoint
    definition and reference this instance. The same test as shown above in Java DSL looks like this:</para>

    <para><emphasis>Java DSL designer</emphasis></para>
    <programlisting language="java">import org.testng.ITestContext;
import org.testng.annotations.Test;
import com.consol.citrus.annotations.CitrusTest;
import com.consol.citrus.dsl.testng.TestNGCitrusTestDesigner;

@Test
public class SendMessageTestDesigner extends TestNGCitrusTestDesigner {

    @CitrusTest(name = "SendMessageTest")
    public void sendMessageTest() {
        description("Basic send message example");

        variable("text", "Hello Citrus!");
        variable("messageId", "Mx1x123456789");

        send("helloServiceEndpoint")
                .payload("&lt;TestMessage&gt;" +
                    "&lt;Text&gt;${text}&lt;/Text&gt;" +
                    "&lt;/TestMessage&gt;")
                .header("Operation", "sayHello")
                .header("RequestTag", "${messageId}");
    }
}</programlisting>

    <para><emphasis>Java DSL runner</emphasis></para>
    <programlisting language="java">import org.testng.ITestContext;
import org.testng.annotations.Test;
import com.consol.citrus.annotations.CitrusTest;
import com.consol.citrus.dsl.testng.TestNGCitrusTestRunner;

@Test
public class SendMessageTestRunner extends TestNGCitrusTestRunner {

    @CitrusTest(name = "SendMessageTest")
    public void sendMessageTest() {
        variable("text", "Hello Citrus!");
        variable("messageId", "Mx1x123456789");

        send(action -> action.endpoint("helloServiceEndpoint")
                .payload("&lt;TestMessage&gt;" +
                        "&lt;Text&gt;${text}&lt;/Text&gt;" +
                    "&lt;/TestMessage&gt;")
                .header("Operation", "sayHello")
                .header("RequestTag", "${messageId}"));
    }
}</programlisting>

    <para>Instead of using the XML tags for send we use methods from <emphasis>TestNGCitrusTestDesigner</emphasis> class. The same message endpoint
    is referenced within the send message action.</para>

    <para>Now that the message sender pattern is clear we can concentrate on how to specify the message content to be sent.
    There are several possibilities for you to define message content in Citrus:</para>

    <itemizedlist mark="opencircle">
        <listitem>
            <para><emphasis>message</emphasis>: This element constructs the message to be sent. There are several child elements available:</para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para><emphasis>payload</emphasis>: Nested XML payload as direct child node.</para>
                </listitem>
                <listitem>
                    <para><emphasis>data</emphasis>: Inline CDATA definition of the message payload</para>
                </listitem>
                <listitem>
                    <para><emphasis>resource</emphasis>: External file resource holding the message payload</para>
                    <para>The syntax would be: &lt;resource file="classpath:com/consol/citrus/messages/TestRequest.xml" /&gt;</para>
                    <para>The file path prefix indicates the resource type, so the file location is resolved either as file system resource (file:)
                        or classpath resource (classpath:).</para>
                </listitem>
                <listitem>
                    <para><emphasis>element</emphasis>: Explicitly overwrite values in the XML message payload using XPath. You can replace message content
                        with dynamic values before sending. Each &lt;element&gt; entry provides a &quot;path&quot; and &quot;value&quot; attribute. The &quot;path&quot;
                        gives a XPath expression evaluating to a XML node element or attribute in the message. The &quot;value&quot; can be a variable expression or any other
                        static value. Citrus will replace the value before sending the message.</para>
                </listitem>
            </itemizedlist>
        </listitem>
        <listitem>
            <para><emphasis>header</emphasis>: Defines a header for the message (e.g. JMS header information or SOAP header):</para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para><emphasis>element</emphasis>: Each header receives a &quot;name&quot; and &quot;value&quot;. The &quot;name&quot; will be the
                        name of the header entry and &quot;value&quot; its respective value. Again the usage of variable expressions as value is supported here, too.</para>
                </listitem>
            </itemizedlist>
        </listitem>
    </itemizedlist>

    <para><emphasis>XML DSL</emphasis></para>
    <programlisting>&lt;send endpoint=&quot;helloServiceEndpoint&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;!-- message payload as XML --&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
&lt;/send&gt;</programlisting>

    <programlisting>&lt;send endpoint=&quot;helloServiceEndpoint&quot;&gt;
    &lt;message&gt;
        &lt;data&gt;
            &lt;![CDATA[
                &lt;!-- message payload as XML --&gt;
            ]]&gt;
        &lt;/data&gt;
    &lt;/message&gt;
&lt;/send&gt;</programlisting>

    <programlisting>&lt;send endpoint=&quot;helloServiceEndpoint&quot;&gt;
    &lt;message&gt;
        &lt;resource file="classpath:com/consol/citrus/messages/TestRequest.xml" /&gt;
    &lt;/message&gt;
&lt;/send&gt;</programlisting>

    <para>The most important thing when dealing with sending actions is to prepare the message payload and header. You are able to construct the message payload either by
    nested XML child nodes (payload), as inline CDATA (&lt;data&gt;) or external file (&lt;resource&gt;).</para>

    <note>
        <para>Sometimes the nested XML message payload elements may cause XSD schema validation rule violations. This is because of variable values not fitting the XSD schema rules
            for example. In this scenario you could also use simple CDATA sections as payload data. In this case you need to use the <literal>&lt;data&gt;</literal> element in contrast
            to the <literal>&lt;payload&gt;</literal> element that we have used in our examples so far.</para>

        <para>With this alternative you can skip the XML schema validation from your IDE at design time. Unfortunately you will loose the XSD auto completion features many XML editors
            offer when constructing your payload.</para>
    </note>

    <para>The The same possibilities apply to the Citrus Java DSL.</para>

    <para><emphasis>Java DSL designer</emphasis></para>
    <programlisting language="java">@CitrusTest
public void messagingTest() {
    send("helloServiceEndpoint")
        .payload("&lt;TestMessage&gt;" +
                "&lt;Text&gt;Hello!&lt;/Text&gt;" +
            "&lt;/TestMessage&gt;");
}</programlisting>

    <programlisting language="java">@CitrusTest
public void messagingTest() {
    send("helloServiceEndpoint")
        .payload(new ClasspathResource("com/consol/citrus/messages/TestRequest.xml"));
}</programlisting>

    <programlisting language="java">@CitrusTest
public void messagingTest() {
    send("helloServiceEndpoint")
        .payloadModel(new TestRequest("Hello Citrus!"));
}</programlisting>

    <programlisting language="java">@CitrusTest
public void messagingTest() {
    send("helloServiceEndpoint")
        .message(new DefaultMessage("<TestRequest><Message>Hello World!</Message></TestRequest>")));
}</programlisting>

    <para>Besides defining message payloads as normal Strings and via external file resource (classpath and file system) you can also use model objects as payload data in Java DSL. This model object
    payload requires a proper message marshaller that should be available as Spring bean inside the application context. By default Citrus is searching for a bean of type <emphasis>org.springframework.oxm.Marshaller</emphasis>.</para>

    <para>In case you have multiple message marshallers in the application context you have to tell Citrus which one to use in this particular send message action.</para>

    <programlisting language="java">@CitrusTest
public void messagingTest() {
    send("helloServiceEndpoint")
        .payloadModel(new TestRequest("Hello Citrus!"), "myMessageMarshallerBean");
}</programlisting>

    <para>Now Citrus will marshal the message paylaod with the message marshaller bean named <emphasis>myMessageMarshallerBean</emphasis>.
    This way you can have multiple message marshaller implementations active in your project (XML, JSON, and so on).</para>

    <para>Last not least the message can be defined as Citrus message object. Here you can choose one of the different message implementations used in Citrus for SOAP, Http or JMS messages. Or you just use the default message implementation or maybe a custom
    implementation.</para>

    <para>Before sending takes place you can explicitly overwrite some message values in payload. You can think of overwriting specific message elements with variable values. Also
    you can overwrite values using XPath(<xref linkend="xpath"/>) or JSONPath (<xref linkend="json-path"/>) expressions.</para>

    <para>The message header is part of our duty of defining proper messages, too. So Citrus uses name-value pairs like &quot;Operation&quot; and &quot;MessageId&quot; in the
    next example to set message header entries. Depending on what message endpoint is used and which message transport underneath the header values will be shipped in different ways.
    In JMS the headers go to the header section of the message, in Http we set mime headers accordingly, in SOAP we can access the SOAP header elements and so on. Citrus aims to do
    the hard work for you. So Citrus knows how to set headers on different message transports.</para>

    <para><emphasis>XML DSL</emphasis></para>
    <programlisting>&lt;send endpoint=&quot;helloServiceEndpoint&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;TestMessage&gt;
                &lt;Text&gt;Hello!&lt;/Text&gt;
            &lt;/TestMessage&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

    <para>The message headers to send are defined by a simple name and value pair. Of course you can use test variables in header values as well. Let's see how this looks like in Java DSL:</para>

    <para><emphasis>Java DSL designer</emphasis></para>
    <programlisting language="java">@CitrusTest
public void messagingTest() {
    receive("helloServiceEndpoint")
        .payload("&lt;TestMessage&gt;" +
                "&lt;Text&gt;Hello!&lt;/Text&gt;" +
            "&lt;/TestMessage&gt;")
        .header("Operation", "sayHello");
}</programlisting>

    <para><emphasis>Java DSL runner</emphasis></para>
    <programlisting language="java">@CitrusTest
public void messagingTest() {
    receive(action -> action.endpoint("helloServiceEndpoint")
        .payload("&lt;TestMessage&gt;" +
                "&lt;Text&gt;Hello!&lt;/Text&gt;" +
            "&lt;/TestMessage&gt;")
        .header("Operation", "sayHello"));
}</programlisting>

    <para>This is basically how to send messages in Citrus. The test case is responsible for constructing the message content while the predefined message endpoint holds transport specific
    settings. Test cases reference endpoint components to publish messages to the outside world. The variable support in message payload and message header
    enables you to add dynamic values before sending out the message.</para>
</section>