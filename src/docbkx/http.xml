<?xml version="1.0" encoding="UTF-8"?>
<chapter id="http">
    <title>HTTP REST support</title>

    <para>REST APIs have gained more and more significance regarding client-server interfaces. The REST client is nothing but a HTTP client sending
    HTTP requests usually in JSON data format to a HTTP server. As HTTP is a synchronous protocol by nature the client receives the server response synchronously.
    Citrus is able to connect with HTTP services and test REST APIs on both client and server side with a powerful JSON message data support. In the next sections you will learn
    how to invoke HTTP services as a client and how to handle REST HTTP requests in a test case. We deal with setting up a HTTP server in order to
    accept client requests and provide proper HTTP responses with GET, PUT, DELETE or POST request method.</para>
    
    <note>
        <para>The http components in Citrus are kept in a separate Maven module. So you should add the module
          as Maven dependency to your project accordingly.</para>

        <programlisting>&lt;dependency&gt;
  &lt;groupId&gt;com.consol.citrus&lt;/groupId&gt;
  &lt;artifactId&gt;citrus-http&lt;/artifactId&gt;
  &lt;version&gt;2.4-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</programlisting>

        <para>As Citrus provides a customized HTTP configuration schema for the Spring application context configuration files we have to add name to the top level
        <emphasis>beans</emphasis> element. Simply include the http-config namespace in the configuration XML files as follows.</para>
        
        <programlisting>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xmlns:citrus=&quot;http://www.citrusframework.org/schema/config&quot;
   xmlns:citrus-http=&quot;http://www.citrusframework.org/schema/http/config&quot;
   xsi:schemaLocation=&quot;
   http://www.springframework.org/schema/beans 
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.citrusframework.org/schema/config 
   http://www.citrusframework.org/schema/config/citrus-config.xsd
   http://www.citrusframework.org/schema/http/config 
   http://www.citrusframework.org/schema/http/config/citrus-http-config.xsd&quot;&gt;
       
    [...]
    
&lt;/beans&gt;</programlisting>
        
        <para>Now we are ready to use the customized Citrus HTTP configuration elements with the
        citrus-http namespace prefix.</para>
    </note>
    
    <section id="http-client">
        <title>HTTP REST client</title>
        
        <para>On the client side we have a simple HTTP message client component connecting to the server. The <b>request-url</b> attribute defines the HTTP server
        endpoint URL to connect to. As usual you can reference this client in your test case in order to send and receive messages. Citrus as client waits for the
        response message from server. After that the response message goes through the validation process as usual. Let us see how a Citrus HTTP client component looks like:</para>
        
        <programlisting>&lt;citrus-http:client id=&quot;helloHttpClient&quot;
          request-url=&quot;http://localhost:8080/hello&quot;
          request-method=&quot;GET&quot;
          content-type=&quot;application/xml&quot;
          timeout=&quot;60000&quot;/&gt;</programlisting>
        
        <para>The <emphasis>request-method</emphasis> defines the HTTP method to use. In addition to that we can specify the content-type of the request we are about to send.
        The client builds the HTTP request and sends it to the HTTP server. While the client is waiting for the synchronous HTTP response to arrive we are able to poll several
        times for the response message in our test case. As usual aou can use the same client endpoint in your test case to send and receive messages synchronously. In case the reply
        message comes in too late according to the timeout settings a respective timeout error is raised.</para>
        
        <para>The request method is statically set to <emphasis>GET</emphasis> in the example above. You can also overwrite the HTTP request method inside the
        sending test action which gives more flexibility. Use something like this in your test:</para>
        
        <programlisting>&lt;send endpoint=&quot;helloHttpClient&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;TestMessage&gt;
                &lt;Text&gt;Hello HttpServer&lt;/Text&gt;
            &lt;/TestMessage&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;citrus_http_method&quot; value=&quot;POST&quot;/&gt;
    &lt;/header&gt;
&lt;/send&gt;</programlisting>
        
        <tip><para>Citrus uses the Spring REST template mechanism for sending out HTTP requests. This means you have great customizing opportunities with a special REST
        template configuration. You can think of basic HTTP authentication, read timeouts and special message factory implementations. Just use the custom REST template
        attribute in client configuration like this:</para>
        
        <programlisting>&lt;citrus-http:client id=&quot;helloHttpClient&quot;
                               request-url=&quot;http://localhost:8080/hello&quot;
                               request-method=&quot;GET&quot;
                               content-type=&quot;text/plain&quot;
                               rest-template=&quot;customizedRestTemplate&quot;/&gt;
                               
&lt;!-- Customized rest template --&gt;
&lt;bean name=&quot;customizedRestTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;&gt;
  &lt;property name=&quot;messageConverters&quot;&gt;
    &lt;util:list id=&quot;converter&quot;&gt;
      &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
        &lt;property name=&quot;supportedMediaTypes&quot;&gt;
          &lt;util:list id=&quot;types&quot;&gt;
            &lt;value&gt;text/plain&lt;/value&gt;
          &lt;/util:list&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/util:list&gt;
  &lt;/property&gt;
  &lt;property name=&quot;errorHandler&quot;&gt;
    &lt;!-- Custom error handler --&gt;
  &lt;/property&gt;
  &lt;property name=&quot;requestFactory&quot;&gt;
    &lt;bean class=&quot;org.springframework.http.client.HttpComponentsClientHttpRequestFactory&quot;&gt;
      &lt;property name=&quot;readTimeout&quot; value=&quot;9000&quot; /&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
        </tip>
        
        <tip><para>Here is another tip for you regarding dynamic endpoint URIs in HTTP clients. Similar to the endpoint resolving mechanism in SOAP you can dynamically set
        the called endpoint URI at test runtime by using special message header values. By default Citrus will check a specific header entry for dynamic endpoint URI which is simply defined for each message sending action
        inside the test.</para>

        <para>The <emphasis>dynamicEndpointResolver</emphasis> bean must implement the EndpointUriResolver interface in order to resolve
          dynamic endpoint uri values. Citrus offers a default implementation, the <emphasis>DynamicEndpointUriResolver</emphasis>, which
          uses a specific message header for setting dynamic endpoint uri. The message header needs to specify the header
          <emphasis>citrus_endpoint_uri</emphasis> with a valid request uri.</para>

        <programlisting>&lt;header&gt;
    &lt;element name=&quot;citrus_endpoint_uri&quot; value=&quot;http://localhost:8080/customers/${customerId}&quot;/&gt;
&lt;/header&gt;</programlisting>
        
        <para>The specific send action above will send its message to the dynamic endpoint (http://localhost:8080/customers/${customerId}) which is set in the header <emphasis>citrus_endpoint_uri</emphasis>. 
        As you can see the endpoint contains a variable entry so you can reuse the same HTTP message client with different endpoint URI. This is essential when calling RESTful WebServices where the
        URI contains parameters, identifiers and modifiers.</para></tip>
    </section>
    
    <section id="http-server">
        <title>HTTP REST server</title>

        <para>The HTTP client was quite easy and straight forward. Receiving HTTP messages is a little bit more complicated because Citrus has to provide server functionality listening on a local port for client
        connections. Therefore Citrus offers an embedded HTTP server which is capable of handling incoming HTTP requests. Once a client connection is accepted the HTTP server must also provide a proper HTTP response
        to the client. In the next few lines you will see how to simulate server side HTTP REST service with Citrus.</para>
        
        <programlisting>&lt;citrus-http:server id=&quot;helloHttpServer&quot;
                port=&quot;8080&quot;
                auto-start=&quot;true&quot;
                resource-base=&quot;src/citrus/resources&quot;/&gt;</programlisting>
        
        <para>Citrus uses an embedded Jetty server that will automatically start when the Spring application context is loaded (auto-start=&quot;true&quot;). The basic connector is listening on
        port <emphasis>8080</emphasis> for requests. Test cases can interact with this server instance via message channels by default. The server provides an inbound channel that holds incoming request messages. The
        test case can receive those requests from the channel with a normal receive test action. In a second step the test case can provide a synchronous response message as reply which will be automatically sent back
        to the HTTP client as response.</para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata align="center" display="block" fileref="figure_008.jpg" format="JPG" />
          </imageobject>

          <imageobject role="html">
            <imagedata align="center" display="block" fileref="figure_008.jpg" format="JPG" />
          </imageobject>
        </mediaobject>

        <para>The figure above shows the basic setup with inbound channel and reply channel. You as a tester should not worry about this to much. By default you as a tester just use the server as synchronous endpoint
        in your test case. This means that you simply receive a message from the server and send a response back.</para>

        <programlisting>&lt;testcase name=&quot;httpServerTest&quot;&gt;
    &lt;actions&gt;
        &lt;receive endpoint=&quot;helloHttpServer&quot;&gt;
            &lt;message&gt;
                &lt;data&gt;
                  [...]
                &lt;/data&gt;
            &lt;/message&gt;
        &lt;/receive&gt;

        &lt;send endpoint=&quot;helloHttpServer&quot;&gt;
            &lt;message&gt;
                &lt;data&gt;
                  [...]
                &lt;/data&gt;
            &lt;/message&gt;
        &lt;/send&gt;
    &lt;/actions&gt;
&lt;/testcase&gt;</programlisting>

        <para>As you can see we reference the server id in both receive and send actions. The Citrus server instance will automatically send the response back to the calling HTTP client. In most cases this is what you need to
        simulate a HTTP server instance in Citrus. Of course we have some more customization possibilities that we will go over right now. This is optional of course so you can also skip the next topics on endpoint adapters if
        you are happy with just what you have learned about the HTTP server component in Citrus.</para>

        <para>The HTTP server component by default uses the channel endpoint adapter in order to forward all incoming requests to an in memory message channel. This is done completely behind the scenes. Those users of you coming
        from older Citrus versions might know how we had to configure this setup somehow verbose in a separate configuration file. But these times have changed as Citrus configuration has become a lot easier in this manner. So now
        the test case does not worry about that settings on the server and just uses the server id reference as synchronous endpoint.</para>

        <tip>
          <para>The default channel endpoint adapter automatically creates an inbound message channel where incoming messages are stored to internally. So if you need to clean up a server that has already stored some incoming messages
            you can do this easily by purging the internal message channel. The message channel follows a naming convention <emphasis>{serverName}.inbound</emphasis> where <emphasis>{serverName}</emphasis> is the Spring bean name of the Citrus server
            endpoint component. If you purge this internal channel in a before test nature you are sure that obsolete messages on a server instance get purged before each test is executed.</para>
        </tip>

        <para>However we do not want to loose the great extendability and customizing capabilities of the Citrus server component. This is why you can optionally define the endpoint adapter implementation used by the Citrus HTTP server. We
        provide several message endpoint adapter implementations for different simulation strategies. With these endpoint adapters you should be able to generate proper response messages for the client in various ways. Before we have a closer
        look at the different adapter implementations we want to show how you can set a custom endpoint adapter on the server component.</para>

        <programlisting>&lt;citrus-http:server id=&quot;helloHttpServer&quot;
          port=&quot;8080&quot;
          auto-start=&quot;true&quot;
          endpoint-adapter=&quot;emptyResponseEndpointAdapter&quot;
          resource-base=&quot;src/citrus/resources&quot;/&gt;

          &lt;citrus:empty-response-adapter id=&quot;emptyResponseEndpointAdapter&quot;/&gt;</programlisting>

        <para>With this endpoint adapter configuration above we change the Citrus server behavior from scratch. Now the server automatically sends back an empty <emphasis>HTTP 200 OK</emphasis> response message every time. Setting a custom endpoint adapter implementation
        with custom logic is easy as defining a custom endpoint adapter Spring bean and reference it in the server attribute. You can read more about endpoint adapters in <xref linkend="endpoint-adapter"/>.</para>
    </section>

    <section id="http-headers">
        <title>HTTP headers</title>

        <para>When dealing with HTTP request/response communication we always deal with HTTP specific headers. The HTTP protocol defines a group of header attributes that both client
        and server need to be able to handle. You can set and validate these HTTP headers in Citrus quite easy. Let us have a look at a client operation in Citrus where some HTTP headers are
        explicitly set before the request is sent out.</para>

        <programlisting>&lt;send endpoint=&quot;httpMessageEndpoint&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;testRequestMessage&gt;
                &lt;text&gt;Hello HttpServer&lt;/text&gt;
            &lt;/testRequestMessage&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;CustomHeaderId&quot; value=&quot;${custom_header_id}&quot;/&gt;
        &lt;element name=&quot;Content-Type&quot; value=&quot;text/xml&quot;/&gt;
        &lt;element name=&quot;Accept&quot; value=&quot;text/xml,*/*&quot;/&gt;
    &lt;/header&gt;
&lt;/send&gt;</programlisting>

        <para>We are able to set custom headers (<emphasis>CustomHeaderId</emphasis>) that go directly into the HTTP header section of the request. In addition to that testers can explicitly set HTTP reserved headers
        such as <emphasis>Content-Type</emphasis>. Fortunately you do not have to set all headers on your own. Citrus will automatically set the required HTTP headers for the request. So we have the following HTTP request
        which is sent to the server:</para>

        <programlisting>POST /test HTTP/1.1
Accept: text/xml, */*
Content-Type: text/xml
CustomHeaderId: 123456789
Accept-Charset: macroman
User-Agent: Jakarta Commons-HttpClient/3.1
Host: localhost:8091
Content-Length: 175
&lt;testRequestMessage&gt;
    &lt;text&gt;Hello HttpServer&lt;/text&gt;
&lt;/testRequestMessage&gt;</programlisting>

        <para>On server side testers are interested in validating the HTTP headers. Within Citrus receive action you simply define the expected header entries. The HTTP specific headers are automatically available for validation
        as you can see in this example:</para>

        <programlisting>&lt;receive endpoint=&quot;httpServer&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;testRequestMessage&gt;
                &lt;text&gt;Hello HttpServer&lt;/text&gt;
            &lt;/testRequestMessage&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;CustomHeaderId&quot; value=&quot;${custom_header_id}&quot;/&gt;
        &lt;element name=&quot;Content-Type&quot; value=&quot;text/xml&quot;/&gt;
        &lt;element name=&quot;Accept&quot; value=&quot;text/xml,*/*&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

        <para>The test checks on custom headers and HTTP specific headers to meet the expected values.</para>

        <para>Now that we have accepted the client request and validated the contents we are able to send back a proper HTTP response message. Same thing here with HTTP specific headers. The HTTP protocol defines several headers
        marking the success or failure of the server operation. In the test case you can set those headers for the response message with conventional Citrus header names. See the following example to find out how that works for you.</para>

        <programlisting>&lt;send endpoint=&quot;httpServer&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;testResponseMessage&gt;
                &lt;text&gt;Hello Citrus Client&lt;/text&gt;
            &lt;/testResponseMessage&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;CustomHeaderId&quot; value=&quot;${custom_header_id}&quot;/&gt;
        &lt;element name=&quot;Content-Type&quot; value=&quot;text/xml&quot;/&gt;
        &lt;element name=&quot;citrus_http_status_code&quot; value=&quot;200&quot;/&gt;
        &lt;element name=&quot;citrus_http_reason_phrase&quot; value=&quot;OK&quot;/&gt;
    &lt;/header&gt;
&lt;/send&gt;</programlisting>

        <para>Once more we set the custom header entry (<emphasis>CustomHeaderId</emphasis>) and a HTTP reserved header (<emphasis>Content-Type</emphasis>) for the response message. On top of this we are able to set the response status for
        the HTTP response. We use the reserved header names <emphasis>citrus_http_status_code</emphasis> in order to mark the success of the server operation. With this mechanism we can easily simulate different server behaviour such as HTTP
        error response codes (e.g. 404 - Not found, 500 - Internal error). Let us have a closer look at the generated response message:</para>

        <programlisting>HTTP/1.1 200 OK
Content-Type: text/xml;charset=UTF-8
Accept-Charset: macroman
Content-Length: 205
Server: Jetty(7.0.0.pre5)
&lt;testResponseMessage&gt;
    &lt;text&gt;Hello Citrus Client&lt;/text&gt;
&lt;/testResponseMessage&gt;</programlisting>

        <tip><para>You do not have to set the reason phrase all the time. It is sufficient to only set the HTTP status code. Citrus will automatically add the proper reason phrase for well known HTTP status codes.</para></tip>

        <para>The only thing that is missing right now is the validation of HTTP status codes when receiving the server response in a Citrus test case. It is very easy as you can use the Citrus reserved header names for validation, too.</para>

        <programlisting>&lt;receive endpoint=&quot;httpClient&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;testResponseMessage&gt;
                &lt;text&gt;Hello Test Framework&lt;/text&gt;
            &lt;/testResponseMessage&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;CustomHeaderId&quot; value=&quot;${custom_header_id}&quot;/&gt;
        &lt;element name=&quot;citrus_http_status_code&quot; value=&quot;200&quot;/&gt;
        &lt;element name=&quot;citrus_http_version&quot; value=&quot;HTTP/1.1&quot;/&gt;
        &lt;element name=&quot;citrus_http_reason_phrase&quot; value=&quot;OK&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

        <para>Up to now we have used some of the basic Citrus reserved HTTP header names (citrus_http_status_code, citrus_http_version, citrus_http_reason_phrase). In HTTP RESTful WebServices some more header names are essential ofr
        validation. These are request attributes like query parameters, context path and request URI. The Citrus server side REST message controller will automatically add all this information to the message header for you. So
        all you need to do is validate the header entries in your test.</para>

        <para>The next example receives a HTTP GET method request on server side. Here the GET request does not have any message payload, so the validation just works on the information given in the message header. We assume
        the client to call <emphasis>http://localhost:8080/app/users?id=123456789</emphasis>. As a tester we need to validate the request method, request URI, context path and the query parameters.</para>

        <programlisting>&lt;receive endpoint=&quot;httpServer&quot;&gt;
    &lt;message&gt;
        &lt;data&gt;&lt;/data&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Host&quot; value=&quot;localhost:8080&quot;/&gt;
        &lt;element name=&quot;Content-Type&quot; value=&quot;text/html&quot;/&gt;
        &lt;element name=&quot;Accept&quot; value=&quot;text/xml,*/*&quot;/&gt;
        &lt;element name=&quot;citrus_http_method&quot; value=&quot;GET&quot;/&gt;
        &lt;element name=&quot;citrus_http_request_uri&quot; value=&quot;/app/users&quot;/&gt;
        &lt;element name=&quot;citrus_http_context_path&quot; value=&quot;/app&quot;/&gt;
        &lt;element name=&quot;citrus_http_query_params&quot; value=&quot;id=123456789&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

        <tip><para>Be aware of the slight differences in request URI and context path. The context path gives you the web application context path within the servlet container for your web application.
        The request URI always gives you the complete path that was called for this request.</para></tip>

        <important><para>Another important thing to notice is the usage of multiple query parameters that are put together using '&amp;' characters (e.g. http://localhost:8080/app/users?id=123456789&amp;name=foo). As the Citrus test case
        is written in XML we have to escape the reserved '&amp;' with &amp;amp; entity (e.g. value=&quot;id=123456789&amp;amp;name=test&quot;).</para></important>

        <para>As you can see we are able to validate all parts of the initial request endpoint URI the client was calling. This completes the HTTP header processing within Citrus.
        On both client and server side Citrus is able to set and validate HTTP specific header entries which is essential for simulating HTTP communication.</para>
    </section>

    <section id="http-error-handling">
        <title>HTTP error handling</title>

        <para>So far we have received response messages with HTTP status code <emphasis>200 OK</emphasis>. How to deal with server errors like <emphasis>404 Not Found</emphasis> or <emphasis>500 Internal server error</emphasis>?
        The default HTTP message client error strategy is to propagate server error response messages to the receive action for validation. We simply check on HTTP status code and status text for error validation.</para>

        <programlisting>&lt;send endpoint=&quot;httpClient&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;testRequestMessage&gt;
                &lt;text&gt;Hello HttpServer&lt;/text&gt;
            &lt;/testRequestMessage&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
&lt;/send&gt;

&lt;receive endpoint=&quot;httpClient&quot;&gt;
    &lt;message&gt;
        &lt;data&gt;&lt;![CDATA[]]&gt;&lt;/data&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;citrus_http_status_code&quot; value=&quot;403&quot;/&gt;
        &lt;element name=&quot;citrus_http_reason_phrase&quot; value=&quot;FORBIDDEN&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

        <para>The message data can be empty depending on the server logic for these error situations. If we receive additional error information as message payload just add validation assertions as usual.</para>

        <para>Instead of receiving such empty messages with checks on HTTP status header information we can change the error strategy in the message sender component in order to automatically raise exceptions
        on response messages other than <emphasis>200 OK</emphasis>. Therefore we go back to the HTTP message sender configuration for changing the error strategy.</para>

        <programlisting>&lt;citrus-http:client id=&quot;httpClient&quot;
                              request-url=&quot;http://localhost:8080/test&quot;
                              error-strategy=&quot;throwsException&quot;/&gt;</programlisting>

        <para>Now we expect an exception to be thrown because of the error response. Following from that we have to change our test case.
        Instead of receiving the error message with receive action we assert the client exception and check on the HTTP status code and status text.</para>

        <programlisting>&lt;assert exception=&quot;org.springframework.web.client.HttpClientErrorException&quot;
           message=&quot;403 Forbidden&quot;&gt;
    &lt;send endpoint=&quot;httpClient&quot;&gt;
        &lt;message&gt;
            &lt;payload&gt;
                &lt;testRequestMessage&gt;
                    &lt;text&gt;Hello HttpServer&lt;/text&gt;
                &lt;/testRequestMessage&gt;
            &lt;/payload&gt;
        &lt;/message&gt;
    &lt;/send&gt;
&lt;/assert&gt;</programlisting>

        <para>Both ways of handling HTTP error messages on client side are valid for expecting the server to raise HTTP error codes. Choose the prefered way according to your test project requirements.</para>
    </section>

    <section id="http-basic-auth-client">
        <title>HTTP client basic authentication</title>

        <para>As client you may have to use basic authentication in order to access a resource on the server. In most cases this will be username/password authentication
        where the credentials are transmitted in the request header section as base64 encoding.</para>

        <para>The easiest approach to set the <emphasis>Authorization</emphasis> header for a basic authentication HTTP request would be to set it on your own in the send action definition. Of course you have
        to use the correct basic authentication header syntax with base64 encoding for the username:password phrase. See this simple example.</para>

        <programlisting>&lt;header&gt;
    &lt;element name=&quot;Authorization&quot; value=&quot;Basic c29tZVVzZXJuYW1lOnNvbWVQYXNzd29yZA==&quot;/&gt;
&lt;/header&gt;</programlisting>

        <para>Citrus will add this header to the HTTP requests and the server will read the <emphasis>Authorization</emphasis> username and password. For more convenient base64 encoding you can also use a Citrus function,
        see <xref linkend="functions-encode-base64"/></para>

        <para>Now there is a more comfortable way to set the basic authentication header in all the Citrus requests. As Citrus uses Spring's REST support with the RestTemplate and ClientHttpRequestFactory the
        basic authentication is already covered there in a more generic way. You simply have to configure the basic authentication credentials on the RestTemplate's ClientHttpRequestFactory. Just see the following
        example and learn how to do that.</para>

        <programlisting>&lt;citrus-http:client id=&quot;httpClient&quot;
                    request-method=&quot;POST&quot;
                    request-url=&quot;http://localhost:8080/test&quot;
                    request-factory=&quot;basicAuthFactory&quot;/&gt;

&lt;bean id=&quot;basicAuthFactory&quot;
    class=&quot;com.consol.citrus.http.client.BasicAuthClientHttpRequestFactory&quot;&gt;
  &lt;property name=&quot;authScope&quot;&gt;
      &lt;bean class=&quot;org.apache.http.auth.AuthScope&quot;&gt;
        &lt;constructor-arg value=&quot;localhost&quot;/&gt;
        &lt;constructor-arg value=&quot;8072&quot;/&gt;
        &lt;constructor-arg value=&quot;&quot;/&gt;
        &lt;constructor-arg value=&quot;basic&quot;/&gt;
      &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name=&quot;credentials&quot;&gt;
    &lt;bean class=&quot;org.apache.http.auth.UsernamePasswordCredentials&quot;&gt;
        &lt;constructor-arg value=&quot;someUsername&quot;/&gt;
        &lt;constructor-arg value=&quot;somePassword&quot;/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para>The advantages of this method is obvious. Now all sending test actions that reference the client component will automatically add the basic authentication header.</para>

        <important><para>Since Citrus has upgraded to Spring 3.1.x the Jakarta commons HTTP client is deprecated with Citrus version 1.2. The formerly used
        UserCredentialsClientHttpRequestFactory is therefore also deprecated and will not continue with next versions. Please update your configuration if you are coming from
        Citrus 1.1 or earlier versions.</para></important>

        <para>The above configuration results in HTTP client requests with authentication headers properly set for basic authentication. The client request factory takes care on adding the proper
        basic authentication header to each request that is sent with this Citrus message sender. Citrus uses preemtive authentication. The message sender only sends a single request to the server with
        all authentication information set in the message header. The request which determines the authentication scheme on the server is skipped. This is why you have to add some auth scope in the client
        request factory so Citrus can setup an authentication cache within the HTTP context in order to have preemtive authentication.</para>

        <para>As a result of the basic auth client request factory the following example request that is created by the Citrus HTTP client has the <emphasis>Authorization</emphasis> header set. This is done
        now automatically for all requests with this HTTP client.</para>

        <programlisting>POST /test HTTP/1.1
Accept: text/xml, */*
Content-Type: text/xml
Accept-Charset: iso-8859-1, us-ascii, utf-8
Authorization: Basic c29tZVVzZXJuYW1lOnNvbWVQYXNzd29yZA==
User-Agent: Jakarta Commons-HttpClient/3.1
Host: localhost:8080
Content-Length: 175
&lt;testRequestMessage&gt;
  &lt;text&gt;Hello HttpServer&lt;/text&gt;
&lt;/testRequestMessage&gt;</programlisting>

    </section>

    <section id="http-basic-auth-server">
        <title>HTTP server basic authentication</title>

        <para>Citrus as a server can also set basic authentication so clients need to authenticate properly when accessing server resources.</para>

        <programlisting>&lt;citrus-http:server id=&quot;basicAuthHttpServer&quot;
                port=&quot;8090&quot;
                auto-start=&quot;true&quot;
                resource-base=&quot;src/citrus/resources&quot;
                security-handler=&quot;basicSecurityHandler&quot;/&gt;

&lt;bean id=&quot;securityHandler&quot; class=&quot;com.consol.citrus.http.security.SecurityHandlerFactory&quot;&gt;
    &lt;property name=&quot;users&quot;&gt;
        &lt;list&gt;
            &lt;bean class=&quot;com.consol.citrus.http.security.User&quot;&gt;
                &lt;property name=&quot;name&quot; value=&quot;citrus&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;secret&quot;/&gt;
                &lt;property name=&quot;roles&quot; value=&quot;CitrusRole&quot;/&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;constraints&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;/foo/*&quot;&gt;
                &lt;bean class=&quot;com.consol.citrus.http.security.BasicAuthConstraint&quot;&gt;
                    &lt;constructor-arg value=&quot;CitrusRole&quot;/&gt;
                &lt;/bean&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para>We have set a security handler on the server web container with a constraint on all resources with <emphasis>/foo/*</emphasis>. Following from that
        the server requires basic authentication for these resources. The granted users and roles are specified within the security handler bean definition. Connecting clients
        have to set the basic auth HTTP header properly using the correct user and role for accessing the Citrus server now.</para>

        <para>You can customize the security handler for your very specific needs (e.g. load users and roles with JDBC from a database). Just have a look at the code base and
        inspect the settings and properties offered by the security handler interface.</para>

        <tip>
            <para>This mechanism is not restricted to basic authentication only. With other settings you can also set up digest or form-based authentication constraints very easy.</para>
        </tip>
    </section>

    <section id="http-servlet-context">
        <title>HTTP servlet context customization</title>

        <para>The Citrus HTTP server uses Spring application context loading on startup. For high customizations you can provide a custom servlet context file which holds all custom
        configurations as Spring beans for the server. Here is a sample servlet context with some basic Spring MVC components and the central HttpMessageController which is responsible for handling
        incoming requests (GET, PUT, DELETE, POST, etc.).</para>

        <programlisting>&lt;bean id=&quot;citrusHandlerMapping&quot; class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;

&lt;bean id=&quot;citrusMethodHandlerAdapter&quot; class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;
  &lt;property name=&quot;messageConverters&quot;&gt;
    &lt;util:list id=&quot;converters&quot;&gt;
      &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
        &lt;property name=&quot;supportedMediaTypes&quot;&gt;
          &lt;util:list&gt;
            &lt;value&gt;text/xml&lt;/value&gt;
          &lt;/util:list&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/util:list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;citrusHttpMessageController&quot; class=&quot;com.consol.citrus.http.controller.HttpMessageController&quot;&gt;
  &lt;property name=&quot;endpointAdapter&quot;&gt;
      &lt;bean
       class=&quot;com.consol.citrus.endpoint.adapter.EmptyResponseEndpointAdapter&quot;/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para>The beans above are responsible for proper HTTP server configuration. In general you do not need to adjust those beans, but we have the possibility to do so which gives
        us a great customization and extension points. The important part is the endpoint adapter definition inside the HttpMessageController. Once a client request was accepted the
        adapter is responsible for generating a proper response to the client.</para>

        <para>You can add the custom servlet context as file resource to the Citrus HTTP server component. Just use the <emphasis>context-config-location</emphasis> attribute as follows:</para>

        <programlisting>&lt;citrus-http:server id=&quot;helloHttpServer&quot;
      port=&quot;8080&quot;
      auto-start=&quot;true&quot;
      context-config-location=&quot;classpath:com/consol/citrus/http/custom-servlet-context.xml&quot;
      resource-base=&quot;src/citrus/resources&quot;/&gt;</programlisting>
    </section>
</chapter>
